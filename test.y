%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>  

/*
 This declaration tells the Bison parser that there's an external function called yylex that will be 
 used as the lexical analyzer (lexer). The yylex function is typically generated by Flex based on the 
 lexer rules.
*/ 
extern int yylex(void);

/*
 This declaration provides access to the variable yytext, which is automatically maintained by Flex.
 yytext contains the current token's text (lexeme) as recognized by the lexer. The parser can use this 
 variable to access the text of the most recently recognized token during parsing actions.
*/
extern char* yytext;            

void yyerror(char* );   //Declaration of yyerror

int olflag=0;           //Flag to check the starting of the Ordered List
int ulflag=0;           //Flag to check the starting of the Unordered List
int linkflag=1;         //Flag to stop textblock from printing when in hyperlinkblock or imageblock
int tableflag=1;        //Flag to stop textblock from printing when in tableblock
int paraflag=1;         //Flag to stop the printing of paragraph tags while using linebreak


/*
 This is a check to close the Ordered list.
*/
void mutex()
{
    if(olflag==1 )
    {
        printf("</ol>");

        olflag=0;
    }
}


/*
 This is a check to close the Urdered list.
*/
void signal()
{
    if(ulflag==1 )
    {
        printf("</ul>");

        ulflag=0;
    }
}



%}


/*
 All the tokens that are used in the lexer file are declared here in the parser file.
*/
%token HEADING1 HEADING2 HEADING3 HEADING4 HEADING5 HEADING6 PARAGRAPH LINEBREAK BLOCKQUOTE
%token BOLD1 BOLD2 ITALICS1 ITALICS2 BOLDITALICS1 BOLDITALICS2_OPEN BOLDITALICS3_OPEN
%token BOLDITALICS2_CLOSE BOLDITALICS3_CLOSE
%token ULS1 ULS2 ULS3 SPACE IMAGE OLS HORIZONTAL STRIKETHROUGH
%token LSQRB RSQRB LB RB EXCLAIM  NEWLINE PIPE SEPERATOR
/*
 The TEXT and URL are specifically declared here with the type str because the tokens returns string of charachter.
*/
%token<str> TEXT URL


%start program   //start symbol for the grammar

/*
 The %union declaration is used to define the types of values that can be associated with tokens and passed between
 the lexer (Flex) and the parser (Bison). This is particularly useful when we need to pass additional information or
 data along with the tokens during parsing.
*/
%union {
    char* str;
}


/*
 Nonterminals in the grammar that may require to passs some char* type value above in grammar.
*/
%type<str> block headingblock orderedlistblock unorderedlistblock boldblock
%type<str> italicsblock bolditalicsblock hyperlinkblock imageblock types  textblock horizontallineblock 

%%

/*
 This is the first production rule which handles all the whitespaces and newline in the start and rest all after that.
*/
program: join {printf("<!DOCTYPE html>");printf("<html><title>Markdown To HTML</title><head></head><body><style>table, th, td {border:1px solid black;}</style><p>");}       
                            
                            cluster 

                            {printf("</P></body></html>");}
;

/*
 This production rule handles the recursive call to handle multiple instances of block production rule elements, 
 it handles multiple newline after the block production rule elements, it handles the paragraph through 3rd rule
 and linebreak through 4th rule, and  
*/

cluster: block join cluster            //This rule handles the recursive call to handle multiple instances of block production rule elements. 

    |    block NEWLINE                 //This rule makes sure that the .md file ends with a newline. 

    |    NEWLINE {signal();mutex();if(paraflag==1) printf("</p><p>");} cluster  //This rule hanldes the Paragraph and multiple newlines.

    |    extraspace {printf("<br>");paraflag=0;} cluster     //This handles the line break and multiple spaces.            
           
    
    ;

block: headingblock                      //This block directs to the Heading handling rules.

    |  orderedlistblock                  //This block directs to the Ordered list handling rules. 

    |  unorderedlistblock                //This block directs to the Unordered list handling rules.

    |  boldblock                         //This block directs to the boldblock handling rules.  

    |  italicsblock                      //This block directs to the italicsblock handling rules.     

    |  bolditalicsblock                  //This block directs to the bolditalicsblock handling rules.     

    |  hyperlinkblock                    //This block directs to the hyperlinkblock handling rules.     

    |  imageblock                        //This block directs to the imageblock handling rules.    

    |  textblock                         //This block directs to the textblock handling rules.  

    |  tableblock                        //This block directs to the tableblock handling rules.

    |  strikethroughblock                //This block directs to the strikethroughblock handling rules.

    |  horizontallineblock               //This block directs to the horizontallineblock handling rules.

    |  blockequoteblock                  //This block directs to the blockequoteblock handling rules.


    ;

headingblock: {signal();mutex();printf("</p>");} HEADING1 {printf("<h1>");} block  {printf("</h1>");printf("<p>");}     //This rule handles the Heading1 statements.

    |         {signal();mutex();printf("</p>");} HEADING2 {printf("<h2>");} block  {printf("</h2>");printf("<p>");}     //This rule handles the Heading2 statements. 

    |         {signal();mutex();printf("</p>");} HEADING3 {printf("<h3>");} block  {printf("</h3>");printf("<p>");}     //This rule handles the Heading3 statements. 

    |         {signal();mutex();printf("</p>");} HEADING4 {printf("<h4>");} block  {printf("</h4>");printf("<p>");}     //This rule handles the Heading4 statements. 

    |         {signal();mutex();printf("</p>");} HEADING5 {printf("<h5>");} block  {printf("</h5>");printf("<p>");}     //This rule handles the Heading5 statements. 

    |         {signal();mutex();printf("</p>");} HEADING6 {printf("<h6>");} block  {printf("</h6>");printf("<p>");}     //This rule handles the Heading6 statements. 
;
    ;

orderedlistblock:   {signal();if(olflag==0) printf("</p><ol>");olflag=1;}OLS {printf("<li>");}    block     {printf("</li>");}     //This rule handles the Ordered list.      

unorderedlistblock: {mutex();if(ulflag==0) printf("</p><ul>");ulflag=1;}ultypes {printf("<li>");} block     {printf("</li>");}     //This rule handles the Unordered list. 
    ;

boldblock: BOLD1  {printf("<strong>");} block BOLD1     {printf("</strong>");}     //This rule handles the Bold  statements.

    | BOLD2 {printf("<strong>");} block BOLD2           {printf("</strong>");}     //This rule handles the Bold statements.
    ;

italicsblock: ITALICS1 {printf("<i>");} block ITALICS1      {printf("</i>");}     //This rule handles the Italics statements.

    |         ITALICS2 {printf("<i>");} block ITALICS2      {printf("</i>");}     //This rule handles the Italics statements.

    ;

bolditalicsblock: BOLD2 ITALICS2 {printf("<i><strong>");} block BOLD2 ITALICS2                 {printf("</strong></i>");}     //This rule handles the Bold and Italics statements.

    |             BOLDITALICS2_OPEN {printf("<i><strong>");} block BOLDITALICS2_CLOSE          {printf("</strong></i>");}     //This rule handles the Bold and Italics statements.
    
    |             BOLDITALICS3_OPEN {printf("<strong><i>");} block BOLDITALICS3_CLOSE          {printf("</strong></i>");}     //This rule handles the Bold and Italics statements.

    ;



hyperlinkblock:
    LSQRB  {linkflag=0;} block  RSQRB LB URL {linkflag=1;} RB            {printf("<a href=\"%s\"> %s </a>",$6,$3);}     //This rule handles the Hyperlinks statements.        
    ;

imageblock:
    EXCLAIM {linkflag=0;}  block  RSQRB LB types {linkflag=1;}  RB       {printf("<img src=\"%s\" alt=\" %s \">",$6,$3);}     //This rule handles the Image statements.          
    ;





ultypes: ULS1
    |    ULS2
    |    ULS3
    ;

join: SPACE      
    | NEWLINE          
    | %empty    
    ;

types:  URL       {$$=$1;}
    |   textblock   
    ;

/*
 This statement handles the structure of table.
*/
tableblock: {signal();mutex();printf("</p>");tableflag=0;} PIPE  {printf("<table><tr>");} firstrow SEPERATOR NEWLINE tablebody  {printf("</table><p>");} 
    ;


/*
 This rule handles the first row of the table.
*/
firstrow:  extraspace textblock extraspace PIPE {printf("<th>%s</th>",$2);} firstrow
    |      extraspace textblock extraspace PIPE {printf("<th>%s</th></tr>",$2);} NEWLINE
    ;

/*
 This rule handles the body of the table.
*/
tablebody:  PIPE {printf("<tr>");} body 
    |       %empty
    ;

body:   extraspace  textblock extraspace  PIPE {printf("<td>%s</td>",$2);} body 
    |   extraspace  textblock extraspace  PIPE {printf("<td>%s</td>",$2);} NEWLINE {printf("</tr>");} tablebody {tableflag=1;}
    ;

strikethroughblock : STRIKETHROUGH {printf("<del> ");} block  {printf(" </del>");} STRIKETHROUGH     //This rule handles the Strikethrough statements.
                   ;

horizontallineblock : HORIZONTAL {printf("<hr>");}     //This rule handles horizontal line. 
                    ;

blockequoteblock : BLOCKQUOTE {printf("</p><blockquote style = \"border:solid 3px ; padding:20px;\"><p>");} block {printf("</p></blockquote><p>");}     //This rule handles the blockquote.
                 ;



textblock: {paraflag=1;} TEXT  { if(linkflag!=0 && tableflag!=0) printf("%s",$2);$$=$2;}     //This rule prints the text statement.
         ;


extraspace: SPACE extraspace       //This rule handles extra spaces
          | %empty

; 





%%

/*
 This function prints the error, when Bison encounters an error during parsing,
 it calls the yyerror function, passing an error message as an argument. 
*/
void yyerror(char *s){
    fprintf(stderr,"error : %s", s);
}


int main() {
     //#ifdef YYDEBUG
             //yydebug=1;
     //#endif
     //Initialize the lexer and parser here
    yyparse(); // Start parsing
    return 0;
}


